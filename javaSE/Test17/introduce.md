### 反射  
在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。   

#### 反射的作用 
- 操作因访问权限限制的属性和方法；
- 实现自定义注解；
- 动态加载第三方jar包，解决android开发中方法数不能超过65536个的问题；
- 按需加载类，节省编译和初始化APK的时间；

#### java.lang.Class类
- Class类的实例表示正在运行的Java应用程序中的类和接口
- Class类是反射的源头
- Class类是Reflection API的入口
- Class类是泛型类
- Class类的对象只能由系统建立对象
- 一个类在JVM中只会有一个Class实例
- 一个Class对象对应的是一个加载到JVM中的一个.class文件
- 每个类的实例都会记得自己是由哪个Class实例所生成
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象
- Class.forName("类的全称")：将字节码文件加载进内存，返回Class对象
- 类名.class：通过类名的属性class获取
- 对象.getClass()：getClass()方法在Object类中定义着。

#### 类的加载器
- 类的加载器负责将类的.class文件加载到内存中，并为之生成对应的Class对象
- JVM自带的加载器
    - 启动类加载器（Bootstrap）：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
    - 扩展类加载器（Extension）：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
    - 应用程序类加载器（AppClassLoader）：负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
    - 自定义类加载器：开发者可以通过继承抽象类java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。

#### 通过反射体现运行时类的对象

#### 反射获取类的运行时结构

#### 动态创建对象执行方法

#### 分析性能问题

#### 通过反射获取泛型

#### 反射操作注解

#### 反射的优劣
灵活、自由度高,但性能、安全性、兼容性存在一定的问题
